<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Instant Pitch & MIDI Detector</title>
    
    <script src="https://cdn.jsdelivr.net/npm/vexflow@4.2.2/build/cjs/vexflow.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    
    <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@500;700&display=swap" rel="stylesheet">
    
    <style>
        body { font-family: 'Dancing Script', cursive; text-align: center; margin-top: 20px; background-color: #fdfbf7; transition: background-color 0.4s ease; font-size: 26px;}
        h2 { color: #333; margin-bottom: 5px; font-size: 48px; font-weight: 700;}
        
        button, select, input, label { font-family: 'Dancing Script', cursive; font-size: 24px; font-weight: 700; }
        
        #menuToggle { display: none; background-color: #343a40; color: white; padding: 10px 20px; border-radius: 8px; border: none; cursor: pointer; margin: 0 auto 15px auto; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        
        .menu-container { display: none; flex-direction: column; align-items: center; background: rgba(255,255,255,0.7); border-radius: 12px; padding: 20px 15px; max-width: 500px; margin: 0 auto 20px auto; box-shadow: 0 4px 15px rgba(0,0,0,0.05); border: 1px solid rgba(0,0,0,0.05); }
        .menu-container.open { display: flex; }

        .controls { display: flex; justify-content: center; gap: 8px; flex-wrap: wrap; width: 100%; margin-bottom: 20px; }
        button { padding: 8px 16px; cursor: pointer; border-radius: 8px; border: none; box-shadow: 0 4px 6px rgba(0,0,0,0.1); color: white; transition: 0.2s; flex-grow: 1; letter-spacing: 1px;}
        
        #startBtn { background-color: #007bff; font-size: 32px; padding: 15px 40px; display: inline-block; margin-top: 30px;}
        #modeToggle { background-color: #6c757d; }
        #instrumentToggle { background-color: #17a2b8; }
        #sourceToggle { background-color: #fd7e14; }
        #clearBtn { background-color: #dc3545; }
        #pdfBtn { background-color: #6f42c1; }
        #playBtn { background-color: #28a745; } 
        
        /* Save/Load Buttons */
        #saveBtn { background-color: #20c997; }
        #loadBtn { background-color: #e83e8c; }
        
        .settings-panel { display: flex; flex-direction: column; align-items: center; width: 100%; color: #333;}
        .setting-row { width: 100%; display: flex; flex-direction: column; margin-bottom: 15px; align-items: center; }
        input[type="range"] { width: 90%; margin-top: 5px; }
        select { padding: 4px 8px; border-radius: 8px; border: 1px solid #ccc; width: 90%; background-color: #fff; cursor: pointer;}
        
        .color-section { display: flex; flex-direction: column; align-items: center; width: 100%; margin-bottom: 15px; }
        .swatch-container { display: flex; gap: 12px; margin-top: 8px; align-items: center; justify-content: center; flex-wrap: wrap;}
        .swatch { width: 36px; height: 36px; border-radius: 50%; border: 2px solid rgba(0,0,0,0.1); cursor: pointer; padding: 0; box-shadow: 0 2px 5px rgba(0,0,0,0.15); flex-grow: 0; transition: transform 0.2s;}
        .swatch:active { transform: scale(0.9); }
        input[type="color"] { width: 40px; height: 40px; padding: 0; border: none; background: none; cursor: pointer; border-radius: 50%;}
        
        #noteDisplay { font-size: 55px; font-weight: bold; color: #000000; margin-top: 10px; transition: color 0.3s;}
        
        .staff-wrapper { width: 95%; margin: 10px auto; overflow-x: auto; background: transparent; min-height: 250px; white-space: nowrap; }
        #staff { display: inline-block; padding: 10px; } 
    </style>
</head>
<body>

    <h2>Piano Transcriber</h2>
    
    <button id="startBtn">Start Application</button>
    <button id="menuToggle">â˜° Controls & Settings</button>
    
    <div class="menu-container" id="mainMenu">
        <div class="controls">
            <button id="playBtn">â–¶ Play</button>
            <button id="saveBtn">ðŸ’¾ Save</button>
            <button id="loadBtn">ðŸ“‚ Load</button>
            <button id="pdfBtn">Export PDF</button>
            <button id="clearBtn">Clear Staff</button>
        </div>
        
        <div class="controls" style="margin-bottom: 10px; border-top: 1px solid rgba(0,0,0,0.1); padding-top: 15px;">
            <button id="sourceToggle">Source: Mic</button>
            <button id="modeToggle">Layout: Grid</button>
            <button id="instrumentToggle">Input: Voice</button>
        </div>

        <div class="settings-panel">
            <div class="setting-row" id="sliderContainer">
                <label for="volSlider">Mic Sensitivity: <strong id="volLabel">0.05</strong></label>
                <input type="range" id="volSlider" min="0.01" max="0.20" step="0.01" value="0.05">
            </div>
            
            <div class="setting-row">
                <label for="bpmSlider">Tempo (BPM): <strong id="bpmLabel">120</strong></label>
                <input type="range" id="bpmSlider" min="40" max="240" step="1" value="120">
            </div>
            
            <div class="setting-row">
                <label for="quantSelect">Note Specificity:</label>
                <select id="quantSelect">
                    <option value="4">Whole Note</option>
                    <option value="2">Half Note</option>
                    <option value="1">Quarter Note</option>
                    <option value="0.5">8th Note</option>
                    <option value="0.25" selected>16th Note</option>
                </select>
            </div>

            <div class="setting-row">
                <label for="keySelect">Key Signature:</label>
                <select id="keySelect">
                    <option value="C" selected>C Major</option>
                    <option value="G">G Major</option>
                    <option value="D">D Major</option>
                    <option value="A">A Major</option>
                    <option value="E">E Major</option>
                    <option value="B">B Major</option>
                    <option value="F">F Major</option>
                    <option value="Bb">Bb Major</option>
                    <option value="Eb">Eb Major</option>
                    <option value="Ab">Ab Major</option>
                    <option value="Db">Db Major</option>
                </select>
            </div>

            <div class="color-section">
                <label>Paper Color</label>
                <div class="swatch-container">
                    <button class="swatch bg-swatch" style="background-color: #fdfbf7;" data-color="#fdfbf7" title="Vintage Cream"></button>
                    <button class="swatch bg-swatch" style="background-color: #e3ebd6;" data-color="#e3ebd6" title="Muted Sage"></button>
                    <button class="swatch bg-swatch" style="background-color: #e1e6f2;" data-color="#e1e6f2" title="Slate Blue"></button>
                    <button class="swatch bg-swatch" style="background-color: #f2e1e1;" data-color="#f2e1e1" title="Dusty Rose"></button>
                    <input type="color" id="bgColorPicker" value="#fdfbf7" title="Custom Paper">
                </div>
            </div>

            <div class="color-section">
                <label>Ink Color</label>
                <div class="swatch-container">
                    <button class="swatch ink-swatch" style="background-color: #000000;" data-color="#000000" title="Pure Black"></button>
                    <button class="swatch ink-swatch" style="background-color: #3b2f2f;" data-color="#3b2f2f" title="Sepia Brown"></button>
                    <button class="swatch ink-swatch" style="background-color: #1a2a40;" data-color="#1a2a40" title="Midnight Navy"></button>
                    <button class="swatch ink-swatch" style="background-color: #4a1c1c;" data-color="#4a1c1c" title="Deep Burgundy"></button>
                    <input type="color" id="inkColorPicker" value="#000000" title="Custom Ink">
                </div>
            </div>
        </div>
    </div>
    
    <div id="noteDisplay">--</div>
    
    <div class="staff-wrapper" id="staffWrapper">
        <div id="staff"></div>
    </div>

    <script>
        let audioContext;
        let analyser;
        let microphone;
        
        const VF = Vex.Flow;
        
        const notesSharp = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        const notesFlat  = ["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"];
        
        const keySignatures = {
            "C":  [], "G":  ["F#"], "D":  ["F#", "C#"], "A":  ["F#", "C#", "G#"], "E":  ["F#", "C#", "G#", "D#"], "B":  ["F#", "C#", "G#", "D#", "A#"],
            "F":  ["Bb"], "Bb": ["Bb", "Eb"], "Eb": ["Bb", "Eb", "Ab"], "Ab": ["Bb", "Eb", "Ab", "Db"], "Db": ["Bb", "Eb", "Ab", "Db", "Gb"]
        };

        let layoutMode = 'page'; 
        let isVoiceMode = true; 
        let inputSource = 'mic'; 
        
        let volumeThreshold = 0.05;
        let targetBPM = 120;
        let minDurationBeats = 0.25; 
        
        let currentKey = "C";
        let currentNoteStrings = notesSharp;
        let inkColor = "#000000"; 
        
        let notesHistory = [];
        let activeNoteName = ""; 
        let activeNoteStartTime = 0;
        let activeNoteIndex = -1;
        
        let activeMidiNotes = new Set();
        let chordRenderTimer = null;
        let renderThrottleTimer = null; // Optimization variable

        const NOTES_PER_LINE = 8;
        const LINES_PER_PAGE = 3;
        let pitchBuffer = []; 
        let silenceFrames = 0; 
        let frameCounter = 0; // Optimization variable

        function applyInkColor(context) {
            context.setFillStyle(inkColor);
            context.setStrokeStyle(inkColor);
        }

        function drawEmptyStaff() {
            const staffDiv = document.getElementById("staff");
            staffDiv.innerHTML = "";
            const renderer = new VF.Renderer(staffDiv, VF.Renderer.Backends.SVG);
            renderer.resize(200, 200);
            const context = renderer.getContext();
            applyInkColor(context);
            
            const stave = new VF.Stave(10, 40, 150);
            stave.addClef("treble").addKeySignature(currentKey).setContext(context).draw();
        }
        drawEmptyStaff();

        // ---------------- SAVE & LOAD LOGIC ----------------
        document.getElementById('saveBtn').addEventListener('click', () => {
            if(notesHistory.length === 0) {
                alert("The staff is empty! Play some notes before saving.");
                return;
            }
            const saveData = {
                notes: notesHistory,
                key: currentKey,
                bpm: targetBPM,
                ink: inkColor,
                bg: document.body.style.backgroundColor
            };
            localStorage.setItem('pianoAppSaveData', JSON.stringify(saveData));
            
            // Visual feedback
            const btn = document.getElementById('saveBtn');
            btn.innerText = "âœ“ Saved!";
            setTimeout(() => btn.innerText = "ðŸ’¾ Save", 2000);
        });

        document.getElementById('loadBtn').addEventListener('click', () => {
            const savedString = localStorage.getItem('pianoAppSaveData');
            if (savedString) {
                const data = JSON.parse(savedString);
                
                // Restore State
                notesHistory = data.notes;
                currentKey = data.key;
                targetBPM = data.bpm;
                inkColor = data.ink;
                document.body.style.backgroundColor = data.bg || '#fdfbf7';
                
                // Update UI Controls to match saved state
                document.getElementById('keySelect').value = currentKey;
                document.getElementById('bpmSlider').value = targetBPM;
                document.getElementById('bpmLabel').innerText = targetBPM;
                document.getElementById('inkColorPicker').value = inkColor;
                document.getElementById('noteDisplay').style.color = inkColor;
                
                // Re-calculate sharp/flat arrays
                let flatKeys = ["F", "Bb", "Eb", "Ab", "Db"];
                currentNoteStrings = flatKeys.includes(currentKey) ? notesFlat : notesSharp;
                
                // Clear any active live notes
                activeNoteName = "";
                activeNoteIndex = -1;
                activeMidiNotes.clear();
                
                renderStaff();
                
                const btn = document.getElementById('loadBtn');
                btn.innerText = "âœ“ Loaded!";
                setTimeout(() => btn.innerText = "ðŸ“‚ Load", 2000);
            } else {
                alert("No saved song found on this device.");
            }
        });

        // ---------------- MENU & COLOR UI LISTENERS ----------------
        document.getElementById('menuToggle').addEventListener('click', () => {
            document.getElementById('mainMenu').classList.toggle('open');
        });

        document.querySelectorAll('.bg-swatch').forEach(btn => {
            btn.addEventListener('click', (e) => {
                let color = e.target.getAttribute('data-color');
                document.body.style.backgroundColor = color;
                document.getElementById('bgColorPicker').value = color;
            });
        });

        document.getElementById('bgColorPicker').addEventListener('input', (e) => {
            document.body.style.backgroundColor = e.target.value;
        });

        document.querySelectorAll('.ink-swatch').forEach(btn => {
            btn.addEventListener('click', (e) => {
                inkColor = e.target.getAttribute('data-color');
                document.getElementById('noteDisplay').style.color = inkColor;
                document.getElementById('inkColorPicker').value = inkColor;
                renderStaff(); 
            });
        });

        document.getElementById('inkColorPicker').addEventListener('input', (e) => {
            inkColor = e.target.value;
            document.getElementById('noteDisplay').style.color = inkColor;
            renderStaff();
        });

        // ---------------- AUDIO PLAYBACK ----------------
        document.getElementById('playBtn').addEventListener('click', () => {
            if (notesHistory.length === 0) return;
            if (audioContext.state === 'suspended') audioContext.resume();
            
            let now = audioContext.currentTime + 0.1; 
            const beatDuration = 60 / targetBPM;
            const durMap = { "w": 4, "h": 2, "q": 1, "8": 0.5, "16": 0.25 };

            notesHistory.forEach(noteObj => {
                let beats = durMap[noteObj.duration] || 1;
                let durationSeconds = beats * beatDuration;
                
                noteObj.midiNotes.forEach(midiNum => {
                    let freq = 440 * Math.pow(2, (midiNum - 69) / 12);
                    let osc = audioContext.createOscillator();
                    let gain = audioContext.createGain();
                    
                    osc.type = 'triangle'; 
                    osc.frequency.value = freq;
                    
                    gain.gain.setValueAtTime(0, now);
                    gain.gain.linearRampToValueAtTime(0.3, now + 0.02); 
                    gain.gain.exponentialRampToValueAtTime(0.001, now + durationSeconds - 0.02); 
                    
                    osc.connect(gain);
                    gain.connect(audioContext.destination);
                    osc.start(now);
                    osc.stop(now + durationSeconds);
                });
                now += durationSeconds;
            });
        });

        // ---------------- CONTROLS ----------------
        document.getElementById('keySelect').addEventListener('change', (e) => {
            currentKey = e.target.value;
            let flatKeys = ["F", "Bb", "Eb", "Ab", "Db"];
            currentNoteStrings = flatKeys.includes(currentKey) ? notesFlat : notesSharp;
            document.getElementById('clearBtn').click(); 
        });

        document.getElementById('bpmSlider').addEventListener('input', (e) => {
            targetBPM = parseInt(e.target.value);
            document.getElementById('bpmLabel').innerText = targetBPM;
        });

        document.getElementById('quantSelect').addEventListener('change', (e) => {
            minDurationBeats = parseFloat(e.target.value);
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            notesHistory = []; 
            activeNoteName = "";
            activeNoteIndex = -1;
            activeMidiNotes.clear();
            pitchBuffer = []; 
            document.getElementById("staff").innerHTML = "";
            drawEmptyStaff();
            document.getElementById('noteDisplay').innerText = "--";
        });

        document.getElementById('modeToggle').addEventListener('click', (e) => {
            if (layoutMode === 'page') {
                layoutMode = 'scroll';
                e.target.innerText = "Layout: Scroll";
                e.target.style.backgroundColor = "#ffc107"; e.target.style.color = "#000";
            } else if (layoutMode === 'scroll') {
                layoutMode = 'single';
                e.target.innerText = "Layout: Single";
                e.target.style.backgroundColor = "#28a745"; e.target.style.color = "#fff";
            } else {
                layoutMode = 'page';
                e.target.innerText = "Layout: Grid";
                e.target.style.backgroundColor = "#6c757d"; e.target.style.color = "#fff";
            }
            document.getElementById('clearBtn').click(); 
        });

        document.getElementById('instrumentToggle').addEventListener('click', (e) => {
            isVoiceMode = !isVoiceMode;
            e.target.innerText = isVoiceMode ? "Input: Voice" : "Input: Piano";
            e.target.style.backgroundColor = isVoiceMode ? "#17a2b8" : "#e83e8c"; 
            pitchBuffer = []; 
        });

                document.getElementById('sourceToggle').addEventListener('click', async (e) => {
            if (inputSource === 'mic') {
                try {
                    const midiAccess = await navigator.requestMIDIAccess();
                    
                    // --- NEW DIAGNOSTIC CHECK ---
                    if (midiAccess.inputs.size === 0) {
                        alert("Browser has permission, but sees 0 keyboards! Check your OTG adapter, phone OTG settings, and ensure the piano is on.");
                        return; // Stop here, don't turn the button purple
                    } else {
                        let deviceNames = [];
                        for (let input of midiAccess.inputs.values()) {
                            deviceNames.push(input.name || "Unknown Keyboard");
                            input.onmidimessage = getMIDIMessage;
                        }
                        // This will pop up telling you exactly what keyboard it found!
                        alert("Success! Connected to: " + deviceNames.join(", "));
                    }
                    // -----------------------------

                    inputSource = 'midi';
                    e.target.innerText = "Source: MIDI";
                    e.target.style.backgroundColor = "#8e44ad"; 
                    document.getElementById('sliderContainer').style.display = 'none';
                    document.getElementById('instrumentToggle').style.display = 'none';
                } catch (err) {
                    alert("MIDI could not be accessed.");
                }
            } else {
                inputSource = 'mic';
                e.target.innerText = "Source: Mic";
                e.target.style.backgroundColor = "#fd7e14"; 
                document.getElementById('sliderContainer').style.display = 'flex';
                document.getElementById('instrumentToggle').style.display = 'inline-block';
            }
            document.getElementById('clearBtn').click();
        });


        document.getElementById('volSlider').addEventListener('input', (e) => {
            volumeThreshold = parseFloat(e.target.value);
            document.getElementById('volLabel').innerText = volumeThreshold.toFixed(2);
        });

        document.getElementById('pdfBtn').addEventListener('click', () => {
            const element = document.getElementById('staff');
            const opt = { margin: 0.5, filename: 'piano-transcription.pdf', image: { type: 'jpeg', quality: 0.98 }, html2canvas: { scale: 2 }, jsPDF: { unit: 'in', format: 'letter', orientation: 'landscape' } };
            html2pdf().set(opt).from(element).save();
        });

        function calculateVexFlowDuration(elapsedBeats) {
            const allowed = [4, 2, 1, 0.5, 0.25].filter(b => b >= minDurationBeats);
            if (allowed.length === 0) allowed.push(minDurationBeats);

            let closest = allowed[0];
            let minDiff = Math.abs(elapsedBeats - closest);
            for(let i = 1; i < allowed.length; i++) {
                let diff = Math.abs(elapsedBeats - allowed[i]);
                if(diff < minDiff) { minDiff = diff; closest = allowed[i]; }
            }

            if (closest === 4) return "w";   
            if (closest === 2) return "h";   
            if (closest === 1) return "q";   
            if (closest === 0.5) return "8"; 
            if (closest === 0.25) return "16"; 
            return "q"; 
        }

        function getAccidental(noteName, key) {
            let baseLetter = noteName[0];
            let isSharp = noteName.includes("#");
            let isFlat = noteName.includes("b");
            let noteAccidental = isSharp ? "#" : (isFlat ? "b" : "n");

            let sigMatch = keySignatures[key].find(n => n.startsWith(baseLetter));
            let sigAccidental = sigMatch ? (sigMatch.includes("#") ? "#" : "b") : "n";

            if (noteAccidental !== sigAccidental) return noteAccidental;
            return null; 
        }

        // ---------------- MIDI ENGINE ----------------
        function getMIDIMessage(midiMessage) {
            if (inputSource !== 'midi') return;
            
            let command = midiMessage.data[0];
            let note = midiMessage.data[1];
            let velocity = (midiMessage.data.length > 2) ? midiMessage.data[2] : 0;
            
            if (command >= 144 && command <= 159 && velocity > 0) {
                activeMidiNotes.add(note);
                if (chordRenderTimer) clearTimeout(chordRenderTimer);
                chordRenderTimer = setTimeout(() => {
                    let notesArray = Array.from(activeMidiNotes).sort((a, b) => a - b);
                    registerNotesAndDraw(notesArray);
                }, 40); 
            }
            
            if ((command >= 128 && command <= 143) || (command >= 144 && command <= 159 && velocity === 0)) {
                activeMidiNotes.delete(note);
                if (activeMidiNotes.size === 0) activeNoteName = ""; 
            }
        }

        // ---------------- DRAWING ENGINE ----------------
        function registerNotesAndDraw(notesArray) {
            let validNotes = notesArray.filter(n => n >= 21 && n <= 108);
            if (validNotes.length === 0) return;

            let vfKeys = [];
            let displayNames = [];
            let accidentals = [];

            validNotes.forEach(note => {
                let noteName = currentNoteStrings[note % 12];
                let octave = Math.floor(note / 12) - 1; 
                vfKeys.push(noteName.toLowerCase() + "/" + octave);
                displayNames.push(noteName + octave);
                accidentals.push(getAccidental(noteName, currentKey)); 
            });

            document.getElementById('noteDisplay').innerText = displayNames.join(" + ");
            let chordID = vfKeys.join("|"); 
                
            if (activeNoteName !== chordID) {
                activeNoteName = chordID;
                activeNoteStartTime = Date.now();
                
                let lowestOctave = Math.floor(validNotes[0] / 12) - 1;
                const clef = lowestOctave >= 4 ? "treble" : "bass";
                let initialDur = calculateVexFlowDuration(0); 
                
                let newNoteData = { keys: vfKeys, clef: clef, accidentals: accidentals, duration: initialDur, midiNotes: validNotes };
                
                if (layoutMode === 'single') {
                    notesHistory = [newNoteData];
                } else {
                    notesHistory.push(newNoteData);
                }
                
                activeNoteIndex = notesHistory.length - 1;
                renderStaff();
            } else {
                let elapsedMs = Date.now() - activeNoteStartTime;
                let beatsElapsed = elapsedMs * (targetBPM / 60000);
                let newDur = calculateVexFlowDuration(beatsElapsed);
                
                // Optimized Redraw: Only trigger renderStaff if the duration literally changed
                if (notesHistory[activeNoteIndex].duration !== newDur) {
                    notesHistory[activeNoteIndex].duration = newDur;
                    renderStaff();
                }
            }
        }

        function renderStaff() {
            if (notesHistory.length === 0) return;

            const staffDiv = document.getElementById("staff");
            staffDiv.innerHTML = ""; 

            if (layoutMode === 'single') {
                const renderer = new VF.Renderer(staffDiv, VF.Renderer.Backends.SVG);
                renderer.resize(200, 200);
                const context = renderer.getContext();
                applyInkColor(context);
                
                let data = notesHistory[0];
                const stave = new VF.Stave(10, 40, 150);
                stave.addClef(data.clef).addKeySignature(currentKey).setContext(context).draw();

                let vfNote = new VF.StaveNote({ keys: data.keys, duration: data.duration, clef: data.clef });
                vfNote.setStyle({fillStyle: inkColor, strokeStyle: inkColor});
                
                data.accidentals.forEach((acc, idx) => {
                    if (acc) vfNote.addModifier(new VF.Accidental(acc), idx);
                });

                const voice = new VF.Voice({ num_beats: 1, beat_value: 4 }).setStrict(false);
                voice.addTickables([vfNote]);
                new VF.Formatter().joinVoices([voice]).format([voice], 100);
                voice.draw(context, stave);
                
            } else if (layoutMode === 'scroll') {
                let dynamicWidth = Math.max(300, notesHistory.length * 55 + 50);
                const renderer = new VF.Renderer(staffDiv, VF.Renderer.Backends.SVG);
                renderer.resize(dynamicWidth, 200); 
                const context = renderer.getContext();
                applyInkColor(context);

                let lineClef = notesHistory[0].clef; 
                let stave = new VF.Stave(10, 40, dynamicWidth - 20);
                stave.addClef(lineClef).addKeySignature(currentKey).setContext(context).draw();

                let voiceNotes = notesHistory.map(data => {
                    let vfN = new VF.StaveNote({ keys: data.keys, duration: data.duration, clef: lineClef });
                    vfN.setStyle({fillStyle: inkColor, strokeStyle: inkColor});
                    data.accidentals.forEach((acc, idx) => {
                        if (acc) vfN.addModifier(new VF.Accidental(acc), idx);
                    });
                    return vfN;
                });

                const voice = new VF.Voice({ num_beats: voiceNotes.length, beat_value: 4 }).setStrict(false);
                voice.addTickables(voiceNotes);
                new VF.Formatter().joinVoices([voice]).format([voice], dynamicWidth - 80);
                voice.draw(context, stave);

                const wrapper = document.getElementById("staffWrapper");
                wrapper.scrollLeft = wrapper.scrollWidth;

            } else {
                let renderHistory = [...notesHistory];
                if (renderHistory.length > NOTES_PER_LINE * LINES_PER_PAGE) {
                    renderHistory = [ renderHistory[renderHistory.length - 1] ];
                    notesHistory = renderHistory;
                    activeNoteIndex = 0;
                }

                const renderer = new VF.Renderer(staffDiv, VF.Renderer.Backends.SVG);
                renderer.resize(400, LINES_PER_PAGE * 120 + 40); 
                const context = renderer.getContext();
                applyInkColor(context);

                for (let i = 0; i < LINES_PER_PAGE; i++) {
                    let startIndex = i * NOTES_PER_LINE;
                    if (startIndex >= renderHistory.length) break;

                    let lineNotesData = renderHistory.slice(startIndex, startIndex + NOTES_PER_LINE);
                    let lineClef = lineNotesData[0].clef; 

                    let stave = new VF.Stave(10, 40 + (i * 120), 350);
                    stave.addClef(lineClef).addKeySignature(currentKey).setContext(context).draw();

                    let voiceNotes = lineNotesData.map(data => {
                        let vfN = new VF.StaveNote({ keys: data.keys, duration: data.duration, clef: lineClef });
                        vfN.setStyle({fillStyle: inkColor, strokeStyle: inkColor});
                        data.accidentals.forEach((acc, idx) => {
                            if (acc) vfN.addModifier(new VF.Accidental(acc), idx);
                        });
                        return vfN;
                    });

                    const voice = new VF.Voice({ num_beats: voiceNotes.length, beat_value: 4 }).setStrict(false);
                    voice.addTickables(voiceNotes);
                    new VF.Formatter().joinVoices([voice]).format([voice], 300);
                    voice.draw(context, stave);
                }
            }
        }

        // ---------------- AUDIO ENGINE (OPTIMIZED) ----------------
        function noteFromPitch(frequency) {
            const noteNum = 12 * (Math.log(frequency / 440) / Math.log(2));
            return Math.round(noteNum) + 69;
        }

        function autoCorrelate(buf, sampleRate) {
            let SIZE = buf.length;
            let rms = 0;
            for (let i = 0; i < SIZE; i++) rms += buf[i] * buf[i];
            rms = Math.sqrt(rms / SIZE);
            if (rms < volumeThreshold) return -1; 

            let r1 = 0, r2 = SIZE - 1, thres = 0.2;
            for (let i = 0; i < SIZE / 2; i++) if (Math.abs(buf[i]) < thres) { r1 = i; break; }
            for (let i = 1; i < SIZE / 2; i++) if (Math.abs(buf[SIZE - i]) < thres) { r2 = SIZE - i; break; }

            buf = buf.slice(r1, r2);
            SIZE = buf.length;

            let c = new Array(SIZE).fill(0);
            for (let i = 0; i < SIZE; i++) {
                for (let j = 0; j < SIZE - i; j++) c[i] = c[i] + buf[j] * buf[j + i];
            }

            let d = 0; while (c[d] > c[d + 1]) d++;
            let maxval = -1, maxpos = -1;
            for (let i = d; i < SIZE; i++) {
                if (c[i] > maxval) { maxval = c[i]; maxpos = i; }
            }
            let T0 = maxpos;
            return sampleRate / T0;
        }

        function updatePitch() {
            requestAnimationFrame(updatePitch);
            
            // OPTIMIZATION: Stop running microphone math entirely if using MIDI
            if (inputSource === 'midi') return; 

            // OPTIMIZATION: Frame Skipper (Runs at ~30fps instead of 60fps to save mobile battery)
            frameCounter++;
            if (frameCounter % 2 !== 0) return;

            let buffer = new Float32Array(analyser.fftSize);
            analyser.getFloatTimeDomainData(buffer);
            
            let sum = 0;
            for(let i=0; i<buffer.length; i++) sum += buffer[i]*buffer[i];
            let volume = Math.sqrt(sum/buffer.length);

            if (volume > volumeThreshold) {
                silenceFrames = 0; 
                let frequency = autoCorrelate(buffer, audioContext.sampleRate);
                
                if (frequency !== -1) {
                    let note = noteFromPitch(frequency);
                    
                    if (isVoiceMode) {
                        pitchBuffer.push(note);
                        if (pitchBuffer.length > 5) pitchBuffer.shift(); 
                        let isStable = pitchBuffer.length === 5 && pitchBuffer.every(val => val === pitchBuffer[0]);
                        if (isStable) registerNotesAndDraw([note]); 
                    } else {
                        registerNotesAndDraw([note]);
                    }
                }
            } else {
                silenceFrames++;
                // Adjusted silence frames due to frame skipper (half as many frames needed)
                let requiredSilence = isVoiceMode ? 8 : 3; 
                
                if (silenceFrames > requiredSilence) {
                    activeNoteName = ""; 
                    document.getElementById('noteDisplay').style.color = inkColor; 
                    pitchBuffer = []; 
                }
            }
        }

        document.getElementById('startBtn').addEventListener('click', async () => {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 2048; 

            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                microphone = audioContext.createMediaStreamSource(stream);
                microphone.connect(analyser);
                updatePitch();
                
                document.getElementById('startBtn').style.display = 'none';
                document.getElementById('menuToggle').style.display = 'block';
                document.getElementById('mainMenu').classList.add('open');
            } catch (err) {
                alert('Microphone access denied or not found.');
            }
        });
    </script>
</body>
</html>
