<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Instant Pitch & MIDI Detector</title>
    
    <script src="https://cdn.jsdelivr.net/npm/vexflow@4.2.2/build/cjs/vexflow.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    
    <style>
        body { font-family: sans-serif; text-align: center; margin-top: 20px; background-color: #f8f9fa;}
        h2 { color: #333; margin-bottom: 10px;}
        
        .controls { display: flex; justify-content: center; gap: 8px; margin-top: 15px; flex-wrap: wrap; max-width: 95%; margin-left: auto; margin-right: auto;}
        
        button { padding: 10px 16px; font-size: 15px; cursor: pointer; border-radius: 8px; border: none; box-shadow: 0 4px 6px rgba(0,0,0,0.1); color: white; transition: 0.2s; flex-grow: 1;}
        #startBtn { background-color: #007bff; font-size: 20px; padding: 15px 30px;}
        #startBtn:active { background-color: #0056b3; }
        
        #modeToggle, #instrumentToggle, #sourceToggle, #clearBtn, #pdfBtn, #rhythmControls { display: none; }
        
        #modeToggle { background-color: #6c757d; }
        #instrumentToggle { background-color: #17a2b8; }
        #sourceToggle { background-color: #fd7e14; }
        #clearBtn { background-color: #dc3545; }
        #pdfBtn { background-color: #6f42c1; }
        
        .settings-panel { margin-top: 20px; display: flex; flex-direction: column; align-items: center; font-size: 14px; color: #555; background: #e9ecef; padding: 15px; border-radius: 8px; max-width: 400px; margin-left: auto; margin-right: auto; box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);}
        input[type="range"] { width: 100%; margin-top: 8px; margin-bottom: 15px; }
        select { padding: 5px; border-radius: 5px; border: 1px solid #ccc; width: 100%; font-size: 16px;}
        
        #noteDisplay { font-size: 35px; font-weight: bold; color: #2c3e50; margin-top: 15px;}
        
        .staff-wrapper {
            width: 95%; margin: 15px auto; overflow-x: auto; background: #fff; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.05); min-height: 250px; white-space: nowrap;
        }
        #staff { display: inline-block; padding: 10px; } 
    </style>
</head>
<body>

    <h2>Live Piano Transcription</h2>
    
    <div class="controls">
        <button id="startBtn">Start Application</button>
        <button id="sourceToggle">Source: Microphone</button>
        <button id="modeToggle">Layout: Sheet Music (Grid)</button>
        <button id="instrumentToggle">Input: Voice Mode</button>
        <button id="pdfBtn">Export to PDF</button>
        <button id="clearBtn">Clear Staff</button>
    </div>

    <div class="settings-panel" id="rhythmControls">
        <div id="sliderContainer" style="width: 100%;">
            <label for="volSlider">Mic Sensitivity: <strong id="volLabel">0.05</strong></label>
            <input type="range" id="volSlider" min="0.01" max="0.20" step="0.01" value="0.05">
        </div>
        
        <label for="bpmSlider">Goal Tempo (BPM): <strong id="bpmLabel">120</strong></label>
        <input type="range" id="bpmSlider" min="40" max="240" step="1" value="120">
        
        <label for="quantSelect">Note Specificity (Quantization):</label>
        <select id="quantSelect">
            <option value="4">Whole Note (Lowest)</option>
            <option value="2">Half Note</option>
            <option value="1">Quarter Note</option>
            <option value="0.5">8th Note</option>
            <option value="0.25" selected>16th Note (Highest)</option>
        </select>
    </div>
    
    <div id="noteDisplay">--</div>
    
    <div class="staff-wrapper" id="staffWrapper">
        <div id="staff"></div>
    </div>

    <script>
        let audioContext;
        let analyser;
        let microphone;
        
        const VF = Vex.Flow;
        const noteStrings = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];

        // State Management 
        let layoutMode = 'page'; 
        let isVoiceMode = true; 
        let inputSource = 'mic'; 
        
        // Settings State
        let volumeThreshold = 0.05;
        let targetBPM = 120;
        let minDurationBeats = 0.25; 
        
        // Engine State
        let notesHistory = [];
        let activeNoteName = "";
        let activeNoteStartTime = 0;
        let activeNoteIndex = -1;

        const NOTES_PER_LINE = 8;
        const LINES_PER_PAGE = 3;
        let pitchBuffer = []; 
        let silenceFrames = 0; 

        function drawEmptyStaff() {
            const staffDiv = document.getElementById("staff");
            staffDiv.innerHTML = "";
            const renderer = new VF.Renderer(staffDiv, VF.Renderer.Backends.SVG);
            renderer.resize(200, 200);
            const context = renderer.getContext();
            const stave = new VF.Stave(10, 40, 150);
            stave.addClef("treble").setContext(context).draw();
        }
        drawEmptyStaff();

        // ---------------- UI EVENT LISTENERS ----------------
        
        document.getElementById('bpmSlider').addEventListener('input', (e) => {
            targetBPM = parseInt(e.target.value);
            document.getElementById('bpmLabel').innerText = targetBPM;
        });

        document.getElementById('quantSelect').addEventListener('change', (e) => {
            minDurationBeats = parseFloat(e.target.value);
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            notesHistory = []; 
            activeNoteName = "";
            activeNoteIndex = -1;
            pitchBuffer = []; 
            document.getElementById("staff").innerHTML = "";
            drawEmptyStaff();
            document.getElementById('noteDisplay').innerText = "--";
        });

        document.getElementById('modeToggle').addEventListener('click', (e) => {
            if (layoutMode === 'page') {
                layoutMode = 'scroll';
                e.target.innerText = "Layout: Horizontal Scroll";
                e.target.style.backgroundColor = "#ffc107"; 
                e.target.style.color = "#000";
            } else if (layoutMode === 'scroll') {
                layoutMode = 'single';
                e.target.innerText = "Layout: Single Note";
                e.target.style.backgroundColor = "#28a745"; 
                e.target.style.color = "#fff";
            } else {
                layoutMode = 'page';
                e.target.innerText = "Layout: Sheet Music (Grid)";
                e.target.style.backgroundColor = "#6c757d"; 
                e.target.style.color = "#fff";
            }
            document.getElementById('clearBtn').click(); 
        });

        document.getElementById('instrumentToggle').addEventListener('click', (e) => {
            isVoiceMode = !isVoiceMode;
            e.target.innerText = isVoiceMode ? "Input: Voice Mode" : "Input: Piano Mode";
            e.target.style.backgroundColor = isVoiceMode ? "#17a2b8" : "#e83e8c"; 
            pitchBuffer = []; 
        });

        document.getElementById('sourceToggle').addEventListener('click', async (e) => {
            if (inputSource === 'mic') {
                try {
                    const midiAccess = await navigator.requestMIDIAccess();
                    for (let input of midiAccess.inputs.values()) {
                        input.onmidimessage = getMIDIMessage;
                    }
                    inputSource = 'midi';
                    e.target.innerText = "Source: USB MIDI";
                    e.target.style.backgroundColor = "#8e44ad"; 
                    document.getElementById('sliderContainer').style.display = 'none';
                    document.getElementById('instrumentToggle').style.display = 'none';
                } catch (err) {
                    alert("MIDI could not be accessed. Ensure your keyboard is plugged in and your browser supports WebMIDI.");
                }
            } else {
                inputSource = 'mic';
                e.target.innerText = "Source: Microphone";
                e.target.style.backgroundColor = "#fd7e14"; 
                document.getElementById('sliderContainer').style.display = 'block';
                document.getElementById('instrumentToggle').style.display = 'inline-block';
            }
            document.getElementById('clearBtn').click();
        });

        document.getElementById('volSlider').addEventListener('input', (e) => {
            volumeThreshold = parseFloat(e.target.value);
            document.getElementById('volLabel').innerText = volumeThreshold.toFixed(2);
        });

        document.getElementById('pdfBtn').addEventListener('click', () => {
            const element = document.getElementById('staff');
            const opt = { margin: 0.5, filename: 'piano-transcription.pdf', image: { type: 'jpeg', quality: 0.98 }, html2canvas: { scale: 2 }, jsPDF: { unit: 'in', format: 'letter', orientation: 'landscape' } };
            html2pdf().set(opt).from(element).save();
        });

        // ---------------- RHYTHM MATH ENGINE ----------------

        function calculateVexFlowDuration(elapsedBeats) {
            // Filter available durations based on user's specificity setting
            const allowed = [4, 2, 1, 0.5, 0.25].filter(b => b >= minDurationBeats);
            if (allowed.length === 0) allowed.push(minDurationBeats);

            // Find the closest mathematical match
            let closest = allowed[0];
            let minDiff = Math.abs(elapsedBeats - closest);
            for(let i = 1; i < allowed.length; i++) {
                let diff = Math.abs(elapsedBeats - allowed[i]);
                if(diff < minDiff) { minDiff = diff; closest = allowed[i]; }
            }

            // Convert raw math to VexFlow string formats
            if (closest === 4) return "w";   // Whole
            if (closest === 2) return "h";   // Half
            if (closest === 1) return "q";   // Quarter
            if (closest === 0.5) return "8"; // 8th
            if (closest === 0.25) return "16"; // 16th
            return "q"; 
        }

        // ---------------- MIDI ENGINE ----------------

        function getMIDIMessage(midiMessage) {
            if (inputSource !== 'midi') return;
            
            let command = midiMessage.data[0];
            let note = midiMessage.data[1];
            let velocity = (midiMessage.data.length > 2) ? midiMessage.data[2] : 0;
            
            let noteName = noteStrings[note % 12];
            let octave = Math.floor(note / 12) - 1; 
            let vfNoteString = noteName.toLowerCase() + "/" + octave;

            // Note On
            if (command >= 144 && command <= 159 && velocity > 0) {
                registerNoteAndDraw(note);
            }
            
            // Note Off (128-143 is Note Off. 144-159 with velocity 0 is also Note Off)
            if ((command >= 128 && command <= 143) || (command >= 144 && command <= 159 && velocity === 0)) {
                if (activeNoteName === vfNoteString) {
                    activeNoteName = ""; // Stop the stopwatch for this note
                }
            }
        }

        // ---------------- DRAWING ENGINE ----------------

        function registerNoteAndDraw(note) {
            let noteName = noteStrings[note % 12];
            let octave = Math.floor(note / 12) - 1; 
            
            if (note >= 21 && note <= 108) {
                let vfNoteString = noteName.toLowerCase() + "/" + octave;
                document.getElementById('noteDisplay').innerText = noteName + octave;
                
                // If this is a NEW note
                if (activeNoteName !== vfNoteString) {
                    activeNoteName = vfNoteString;
                    activeNoteStartTime = Date.now();
                    
                    const clef = octave >= 4 ? "treble" : "bass";
                    let initialDur = calculateVexFlowDuration(0); // Start with minimum allowed length
                    
                    let newNoteData = { keys: [vfNoteString], clef: clef, name: noteName, duration: initialDur };
                    
                    if (layoutMode === 'single') {
                        notesHistory = [newNoteData];
                    } else {
                        notesHistory.push(newNoteData);
                    }
                    
                    activeNoteIndex = notesHistory.length - 1;
                    renderStaff();
                } 
                // If the SAME note is still being held down
                else {
                    let elapsedMs = Date.now() - activeNoteStartTime;
                    let beatsElapsed = elapsedMs * (targetBPM / 60000);
                    let newDur = calculateVexFlowDuration(beatsElapsed);
                    
                    // Update and Redraw only if the duration mathematically crosses a threshold
                    if (notesHistory[activeNoteIndex].duration !== newDur) {
                        notesHistory[activeNoteIndex].duration = newDur;
                        renderStaff();
                    }
                }
            }
        }

        function renderStaff() {
            if (notesHistory.length === 0) return;

            const staffDiv = document.getElementById("staff");
            staffDiv.innerHTML = ""; 

            if (layoutMode === 'single') {
                const renderer = new VF.Renderer(staffDiv, VF.Renderer.Backends.SVG);
                renderer.resize(200, 200);
                const context = renderer.getContext();
                
                let data = notesHistory[0];
                const stave = new VF.Stave(10, 40, 150);
                stave.addClef(data.clef).setContext(context).draw();

                let vfNote = new VF.StaveNote({ keys: data.keys, duration: data.duration, clef: data.clef });
                if (data.name.includes("#")) vfNote.addModifier(new VF.Accidental("#"), 0);

                const voice = new VF.Voice({ num_beats: 1, beat_value: 4 }).setStrict(false);
                voice.addTickables([vfNote]);
                new VF.Formatter().joinVoices([voice]).format([voice], 100);
                voice.draw(context, stave);
                
            } else if (layoutMode === 'scroll') {
                let dynamicWidth = Math.max(300, notesHistory.length * 55 + 50);
                const renderer = new VF.Renderer(staffDiv, VF.Renderer.Backends.SVG);
                renderer.resize(dynamicWidth, 200); 
                const context = renderer.getContext();

                let lineClef = notesHistory[0].clef; 
                let stave = new VF.Stave(10, 40, dynamicWidth - 20);
                stave.addClef(lineClef).setContext(context).draw();

                let voiceNotes = notesHistory.map(data => {
                    let vfN = new VF.StaveNote({ keys: data.keys, duration: data.duration, clef: lineClef });
                    if (data.name.includes("#")) vfN.addModifier(new VF.Accidental("#"), 0);
                    return vfN;
                });

                const voice = new VF.Voice({ num_beats: voiceNotes.length, beat_value: 4 }).setStrict(false);
                voice.addTickables(voiceNotes);
                new VF.Formatter().joinVoices([voice]).format([voice], dynamicWidth - 80);
                voice.draw(context, stave);

                const wrapper = document.getElementById("staffWrapper");
                wrapper.scrollLeft = wrapper.scrollWidth;

            } else {
                // PAGE (GRID) MODE
                let renderHistory = [...notesHistory];
                if (renderHistory.length > NOTES_PER_LINE * LINES_PER_PAGE) {
                    renderHistory = [ renderHistory[renderHistory.length - 1] ];
                    notesHistory = renderHistory;
                    activeNoteIndex = 0;
                }

                const renderer = new VF.Renderer(staffDiv, VF.Renderer.Backends.SVG);
                renderer.resize(400, LINES_PER_PAGE * 120 + 40); 
                const context = renderer.getContext();

                for (let i = 0; i < LINES_PER_PAGE; i++) {
                    let startIndex = i * NOTES_PER_LINE;
                    if (startIndex >= renderHistory.length) break;

                    let lineNotesData = renderHistory.slice(startIndex, startIndex + NOTES_PER_LINE);
                    let lineClef = lineNotesData[0].clef; 

                    let stave = new VF.Stave(10, 40 + (i * 120), 350);
                    stave.addClef(lineClef).setContext(context).draw();

                    let voiceNotes = lineNotesData.map(data => {
                        let vfN = new VF.StaveNote({ keys: data.keys, duration: data.duration, clef: lineClef });
                        if (data.name.includes("#")) vfN.addModifier(new VF.Accidental("#"), 0);
                        return vfN;
                    });

                    const voice = new VF.Voice({ num_beats: voiceNotes.length, beat_value: 4 }).setStrict(false);
                    voice.addTickables(voiceNotes);
                    
                    new VF.Formatter().joinVoices([voice]).format([voice], 300);
                    voice.draw(context, stave);
                }
            }
        }

        // ---------------- AUDIO ENGINE ----------------

        function noteFromPitch(frequency) {
            const noteNum = 12 * (Math.log(frequency / 440) / Math.log(2));
            return Math.round(noteNum) + 69;
        }

        function autoCorrelate(buf, sampleRate) {
            let SIZE = buf.length;
            let rms = 0;
            for (let i = 0; i < SIZE; i++) rms += buf[i] * buf[i];
            rms = Math.sqrt(rms / SIZE);
            if (rms < volumeThreshold) return -1; 

            let r1 = 0, r2 = SIZE - 1, thres = 0.2;
            for (let i = 0; i < SIZE / 2; i++) if (Math.abs(buf[i]) < thres) { r1 = i; break; }
            for (let i = 1; i < SIZE / 2; i++) if (Math.abs(buf[SIZE - i]) < thres) { r2 = SIZE - i; break; }

            buf = buf.slice(r1, r2);
            SIZE = buf.length;

            let c = new Array(SIZE).fill(0);
            for (let i = 0; i < SIZE; i++) {
                for (let j = 0; j < SIZE - i; j++) c[i] = c[i] + buf[j] * buf[j + i];
            }

            let d = 0; while (c[d] > c[d + 1]) d++;
            let maxval = -1, maxpos = -1;
            for (let i = d; i < SIZE; i++) {
                if (c[i] > maxval) { maxval = c[i]; maxpos = i; }
            }
            let T0 = maxpos;
            return sampleRate / T0;
        }

        function updatePitch() {
            requestAnimationFrame(updatePitch);
            
            if (inputSource === 'midi') return; 

            let buffer = new Float32Array(analyser.fftSize);
            analyser.getFloatTimeDomainData(buffer);
            
            let sum = 0;
            for(let i=0; i<buffer.length; i++) sum += buffer[i]*buffer[i];
            let volume = Math.sqrt(sum/buffer.length);

            if (volume > volumeThreshold) {
                silenceFrames = 0; 
                let frequency = autoCorrelate(buffer, audioContext.sampleRate);
                
                if (frequency !== -1) {
                    let note = noteFromPitch(frequency);
                    
                    if (isVoiceMode) {
                        pitchBuffer.push(note);
                        if (pitchBuffer.length > 5) pitchBuffer.shift(); 
                        let isStable = pitchBuffer.length === 5 && pitchBuffer.every(val => val === pitchBuffer[0]);
                        if (isStable) registerNoteAndDraw(note);
                    } else {
                        registerNoteAndDraw(note);
                    }
                }
            } else {
                silenceFrames++;
                let requiredSilence = isVoiceMode ? 15 : 5; 
                
                if (silenceFrames > requiredSilence) {
                    activeNoteName = ""; // Stop the microphone stopwatch!
                    document.getElementById('noteDisplay').style.color = "#2c3e50";
                    pitchBuffer = []; 
                }
            }
        }

        document.getElementById('startBtn').addEventListener('click', async () => {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 2048; 

            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                microphone = audioContext.createMediaStreamSource(stream);
                microphone.connect(analyser);
                updatePitch();
                
                document.getElementById('startBtn').style.display = 'none';
                document.getElementById('sourceToggle').style.display = 'inline-block';
                document.getElementById('modeToggle').style.display = 'inline-block';
                document.getElementById('instrumentToggle').style.display = 'inline-block';
                document.getElementById('pdfBtn').style.display = 'inline-block';
                document.getElementById('clearBtn').style.display = 'inline-block';
                document.getElementById('rhythmControls').style.display = 'flex';
            } catch (err) {
                alert('Microphone access denied or not found.');
            }
        });
    </script>
</body>
</html>
