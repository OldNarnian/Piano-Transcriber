<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Instant Pitch & MIDI Detector</title>
    
    <script src="https://cdn.jsdelivr.net/npm/vexflow@4.2.2/build/cjs/vexflow.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    
    <style>
        body { font-family: sans-serif; text-align: center; margin-top: 20px; background-color: #f8f9fa;}
        h2 { color: #333; margin-bottom: 10px;}
        
        .controls { display: flex; justify-content: center; gap: 8px; margin-top: 15px; flex-wrap: wrap; max-width: 95%; margin-left: auto; margin-right: auto;}
        
        button { padding: 10px 16px; font-size: 15px; cursor: pointer; border-radius: 8px; border: none; box-shadow: 0 4px 6px rgba(0,0,0,0.1); color: white; transition: 0.2s; flex-grow: 1;}
        #startBtn { background-color: #007bff; font-size: 20px; padding: 15px 30px;}
        #startBtn:active { background-color: #0056b3; }
        
        #modeToggle, #instrumentToggle, #sourceToggle, #clearBtn, #pdfBtn, #rhythmControls { display: none; }
        
        #modeToggle { background-color: #6c757d; }
        #instrumentToggle { background-color: #17a2b8; }
        #sourceToggle { background-color: #fd7e14; }
        #clearBtn { background-color: #dc3545; }
        #pdfBtn { background-color: #6f42c1; }
        
        .settings-panel { margin-top: 20px; display: flex; flex-direction: column; align-items: center; font-size: 14px; color: #555; background: #e9ecef; padding: 15px; border-radius: 8px; max-width: 400px; margin-left: auto; margin-right: auto; box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);}
        input[type="range"] { width: 100%; margin-top: 8px; margin-bottom: 15px; }
        select { padding: 5px; border-radius: 5px; border: 1px solid #ccc; width: 100%; font-size: 16px; margin-bottom: 15px;}
        
        #noteDisplay { font-size: 30px; font-weight: bold; color: #2c3e50; margin-top: 15px;}
        
        .staff-wrapper {
            width: 95%; margin: 15px auto; overflow-x: auto; background: #fff; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.05); min-height: 250px; white-space: nowrap;
        }
        #staff { display: inline-block; padding: 10px; } 
    </style>
</head>
<body>

    <h2>Live Piano Transcription</h2>
    
    <div class="controls">
        <button id="startBtn">Start Application</button>
        <button id="sourceToggle">Source: Microphone</button>
        <button id="modeToggle">Layout: Sheet Music (Grid)</button>
        <button id="instrumentToggle">Input: Voice Mode</button>
        <button id="pdfBtn">Export to PDF</button>
        <button id="clearBtn">Clear Staff</button>
    </div>

    <div class="settings-panel" id="rhythmControls">
        <div id="sliderContainer" style="width: 100%;">
            <label for="volSlider">Mic Sensitivity: <strong id="volLabel">0.05</strong></label>
            <input type="range" id="volSlider" min="0.01" max="0.20" step="0.01" value="0.05">
        </div>
        
        <label for="bpmSlider">Goal Tempo (BPM): <strong id="bpmLabel">120</strong></label>
        <input type="range" id="bpmSlider" min="40" max="240" step="1" value="120">
        
        <label for="quantSelect">Note Specificity (Quantization):</label>
        <select id="quantSelect">
            <option value="4">Whole Note (Lowest)</option>
            <option value="2">Half Note</option>
            <option value="1">Quarter Note</option>
            <option value="0.5">8th Note</option>
            <option value="0.25" selected>16th Note (Highest)</option>
        </select>

        <label for="keySelect">Song Key Signature:</label>
        <select id="keySelect">
            <option value="C" selected>C Major (No Sharps/Flats)</option>
            <option value="G">G Major (1 Sharp)</option>
            <option value="D">D Major (2 Sharps)</option>
            <option value="A">A Major (3 Sharps)</option>
            <option value="E">E Major (4 Sharps)</option>
            <option value="B">B Major (5 Sharps)</option>
            <option value="F">F Major (1 Flat)</option>
            <option value="Bb">Bb Major (2 Flats)</option>
            <option value="Eb">Eb Major (3 Flats)</option>
            <option value="Ab">Ab Major (4 Flats)</option>
            <option value="Db">Db Major (5 Flats)</option>
        </select>
    </div>
    
    <div id="noteDisplay">--</div>
    
    <div class="staff-wrapper" id="staffWrapper">
        <div id="staff"></div>
    </div>

    <script>
        let audioContext;
        let analyser;
        let microphone;
        
        const VF = Vex.Flow;
        
        // Music Theory Engine
        const notesSharp = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        const notesFlat  = ["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"];
        
        const keySignatures = {
            "C":  [],
            "G":  ["F#"],
            "D":  ["F#", "C#"],
            "A":  ["F#", "C#", "G#"],
            "E":  ["F#", "C#", "G#", "D#"],
            "B":  ["F#", "C#", "G#", "D#", "A#"],
            "F":  ["Bb"],
            "Bb": ["Bb", "Eb"],
            "Eb": ["Bb", "Eb", "Ab"],
            "Ab": ["Bb", "Eb", "Ab", "Db"],
            "Db": ["Bb", "Eb", "Ab", "Db", "Gb"]
        };

        // State Management 
        let layoutMode = 'page'; 
        let isVoiceMode = true; 
        let inputSource = 'mic'; 
        
        let volumeThreshold = 0.05;
        let targetBPM = 120;
        let minDurationBeats = 0.25; 
        
        let currentKey = "C";
        let currentNoteStrings = notesSharp;
        
        // Engine State
        let notesHistory = [];
        let activeNoteName = ""; 
        let activeNoteStartTime = 0;
        let activeNoteIndex = -1;
        
        let activeMidiNotes = new Set();
        let chordRenderTimer = null;

        const NOTES_PER_LINE = 8;
        const LINES_PER_PAGE = 3;
        let pitchBuffer = []; 
        let silenceFrames = 0; 

        function drawEmptyStaff() {
            const staffDiv = document.getElementById("staff");
            staffDiv.innerHTML = "";
            const renderer = new VF.Renderer(staffDiv, VF.Renderer.Backends.SVG);
            renderer.resize(200, 200);
            const context = renderer.getContext();
            const stave = new VF.Stave(10, 40, 150);
            stave.addClef("treble").addKeySignature(currentKey).setContext(context).draw();
        }
        drawEmptyStaff();

        // ---------------- UI EVENT LISTENERS ----------------
        
        document.getElementById('keySelect').addEventListener('change', (e) => {
            currentKey = e.target.value;
            let flatKeys = ["F", "Bb", "Eb", "Ab", "Db"];
            currentNoteStrings = flatKeys.includes(currentKey) ? notesFlat : notesSharp;
            document.getElementById('clearBtn').click(); 
        });

        document.getElementById('bpmSlider').addEventListener('input', (e) => {
            targetBPM = parseInt(e.target.value);
            document.getElementById('bpmLabel').innerText = targetBPM;
        });

        document.getElementById('quantSelect').addEventListener('change', (e) => {
            minDurationBeats = parseFloat(e.target.value);
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            notesHistory = []; 
            activeNoteName = "";
            activeNoteIndex = -1;
            activeMidiNotes.clear();
            pitchBuffer = []; 
            document.getElementById("staff").innerHTML = "";
            drawEmptyStaff();
            document.getElementById('noteDisplay').innerText = "--";
        });

        document.getElementById('modeToggle').addEventListener('click', (e) => {
            if (layoutMode === 'page') {
                layoutMode = 'scroll';
                e.target.innerText = "Layout: Horizontal Scroll";
                e.target.style.backgroundColor = "#ffc107"; e.target.style.color = "#000";
            } else if (layoutMode === 'scroll') {
                layoutMode = 'single';
                e.target.innerText = "Layout: Single Note";
                e.target.style.backgroundColor = "#28a745"; e.target.style.color = "#fff";
            } else {
                layoutMode = 'page';
                e.target.innerText = "Layout: Sheet Music (Grid)";
                e.target.style.backgroundColor = "#6c757d"; e.target.style.color = "#fff";
            }
            document.getElementById('clearBtn').click(); 
        });

        document.getElementById('instrumentToggle').addEventListener('click', (e) => {
            isVoiceMode = !isVoiceMode;
            e.target.innerText = isVoiceMode ? "Input: Voice Mode" : "Input: Piano Mode";
            e.target.style.backgroundColor = isVoiceMode ? "#17a2b8" : "#e83e8c"; 
            pitchBuffer = []; 
        });

        document.getElementById('sourceToggle').addEventListener('click', async (e) => {
            if (inputSource === 'mic') {
                try {
                    const midiAccess = await navigator.requestMIDIAccess();
                    for (let input of midiAccess.inputs.values()) {
                        input.onmidimessage = getMIDIMessage;
                    }
                    inputSource = 'midi';
                    e.target.innerText = "Source: USB MIDI";
                    e.target.style.backgroundColor = "#8e44ad"; 
                    document.getElementById('sliderContainer').style.display = 'none';
                    document.getElementById('instrumentToggle').style.display = 'none';
                } catch (err) {
                    alert("MIDI could not be accessed.");
                }
            } else {
                inputSource = 'mic';
                e.target.innerText = "Source: Microphone";
                e.target.style.backgroundColor = "#fd7e14"; 
                document.getElementById('sliderContainer').style.display = 'block';
                document.getElementById('instrumentToggle').style.display = 'inline-block';
            }
            document.getElementById('clearBtn').click();
        });

        document.getElementById('volSlider').addEventListener('input', (e) => {
            volumeThreshold = parseFloat(e.target.value);
            document.getElementById('volLabel').innerText = volumeThreshold.toFixed(2);
        });

        document.getElementById('pdfBtn').addEventListener('click', () => {
            const element = document.getElementById('staff');
            const opt = { margin: 0.5, filename: 'piano-transcription.pdf', image: { type: 'jpeg', quality: 0.98 }, html2canvas: { scale: 2 }, jsPDF: { unit: 'in', format: 'letter', orientation: 'landscape' } };
            html2pdf().set(opt).from(element).save();
        });

        // ---------------- RHYTHM & THEORY MATH ----------------

        function calculateVexFlowDuration(elapsedBeats) {
            const allowed = [4, 2, 1, 0.5, 0.25].filter(b => b >= minDurationBeats);
            if (allowed.length === 0) allowed.push(minDurationBeats);

            let closest = allowed[0];
            let minDiff = Math.abs(elapsedBeats - closest);
            for(let i = 1; i < allowed.length; i++) {
                let diff = Math.abs(elapsedBeats - allowed[i]);
                if(diff < minDiff) { minDiff = diff; closest = allowed[i]; }
            }

            if (closest === 4) return "w";   
            if (closest === 2) return "h";   
            if (closest === 1) return "q";   
            if (closest === 0.5) return "8"; 
            if (closest === 0.25) return "16"; 
            return "q"; 
        }

        function getAccidental(noteName, key) {
            let baseLetter = noteName[0];
            let isSharp = noteName.includes("#");
            let isFlat = noteName.includes("b");
            let noteAccidental = isSharp ? "#" : (isFlat ? "b" : "n");

            let sigMatch = keySignatures[key].find(n => n.startsWith(baseLetter));
            let sigAccidental = sigMatch ? (sigMatch.includes("#") ? "#" : "b") : "n";

            // Only return an accidental if the note deviates from the key signature
            if (noteAccidental !== sigAccidental) {
                return noteAccidental;
            }
            return null; 
        }

        // ---------------- MIDI ENGINE ----------------

        function getMIDIMessage(midiMessage) {
            if (inputSource !== 'midi') return;
            
            let command = midiMessage.data[0];
            let note = midiMessage.data[1];
            let velocity = (midiMessage.data.length > 2) ? midiMessage.data[2] : 0;
            
            if (command >= 144 && command <= 159 && velocity > 0) {
                activeMidiNotes.add(note);
                if (chordRenderTimer) clearTimeout(chordRenderTimer);
                chordRenderTimer = setTimeout(() => {
                    let notesArray = Array.from(activeMidiNotes).sort((a, b) => a - b);
                    registerNotesAndDraw(notesArray);
                }, 40); 
            }
            
            if ((command >= 128 && command <= 143) || (command >= 144 && command <= 159 && velocity === 0)) {
                activeMidiNotes.delete(note);
                if (activeMidiNotes.size === 0) activeNoteName = ""; 
            }
        }

        // ---------------- DRAWING ENGINE ----------------

        function registerNotesAndDraw(notesArray) {
            let validNotes = notesArray.filter(n => n >= 21 && n <= 108);
            if (validNotes.length === 0) return;

            let vfKeys = [];
            let displayNames = [];
            let accidentals = [];

            validNotes.forEach(note => {
                let noteName = currentNoteStrings[note % 12];
                let octave = Math.floor(note / 12) - 1; 
                vfKeys.push(noteName.toLowerCase() + "/" + octave);
                displayNames.push(noteName + octave);
                
                // Determine if we explicitly need to draw a #, b, or natural sign
                let requiredAccidental = getAccidental(noteName, currentKey);
                accidentals.push(requiredAccidental); 
            });

            document.getElementById('noteDisplay').innerText = displayNames.join(" + ");
            let chordID = vfKeys.join("|"); 
                
            if (activeNoteName !== chordID) {
                activeNoteName = chordID;
                activeNoteStartTime = Date.now();
                
                let lowestOctave = Math.floor(validNotes[0] / 12) - 1;
                const clef = lowestOctave >= 4 ? "treble" : "bass";
                let initialDur = calculateVexFlowDuration(0); 
                
                let newNoteData = { keys: vfKeys, clef: clef, accidentals: accidentals, duration: initialDur };
                
                if (layoutMode === 'single') {
                    notesHistory = [newNoteData];
                } else {
                    notesHistory.push(newNoteData);
                }
                
                activeNoteIndex = notesHistory.length - 1;
                renderStaff();
            } else {
                let elapsedMs = Date.now() - activeNoteStartTime;
                let beatsElapsed = elapsedMs * (targetBPM / 60000);
                let newDur = calculateVexFlowDuration(beatsElapsed);
                
                if (notesHistory[activeNoteIndex].duration !== newDur) {
                    notesHistory[activeNoteIndex].duration = newDur;
                    renderStaff();
                }
            }
        }

        function renderStaff() {
            if (notesHistory.length === 0) return;

            const staffDiv = document.getElementById("staff");
            staffDiv.innerHTML = ""; 

            if (layoutMode === 'single') {
                const renderer = new VF.Renderer(staffDiv, VF.Renderer.Backends.SVG);
                renderer.resize(200, 200);
                const context = renderer.getContext();
                
                let data = notesHistory[0];
                const stave = new VF.Stave(10, 40, 150);
                stave.addClef(data.clef).addKeySignature(currentKey).setContext(context).draw();

                let vfNote = new VF.StaveNote({ keys: data.keys, duration: data.duration, clef: data.clef });
                data.accidentals.forEach((acc, idx) => {
                    if (acc) vfNote.addModifier(new VF.Accidental(acc), idx);
                });

                const voice = new VF.Voice({ num_beats: 1, beat_value: 4 }).setStrict(false);
                voice.addTickables([vfNote]);
                new VF.Formatter().joinVoices([voice]).format([voice], 100);
                voice.draw(context, stave);
                
            } else if (layoutMode === 'scroll') {
                let dynamicWidth = Math.max(300, notesHistory.length * 55 + 50);
                const renderer = new VF.Renderer(staffDiv, VF.Renderer.Backends.SVG);
                renderer.resize(dynamicWidth, 200); 
                const context = renderer.getContext();

                let lineClef = notesHistory[0].clef; 
                let stave = new VF.Stave(10, 40, dynamicWidth - 20);
                stave.addClef(lineClef).addKeySignature(currentKey).setContext(context).draw();

                let voiceNotes = notesHistory.map(data => {
                    let vfN = new VF.StaveNote({ keys: data.keys, duration: data.duration, clef: lineClef });
                    data.accidentals.forEach((acc, idx) => {
                        if (acc) vfN.addModifier(new VF.Accidental(acc), idx);
                    });
                    return vfN;
                });

                const voice = new VF.Voice({ num_beats: voiceNotes.length, beat_value: 4 }).setStrict(false);
                voice.addTickables(voiceNotes);
                new VF.Formatter().joinVoices([voice]).format([voice], dynamicWidth - 80);
                voice.draw(context, stave);

                const wrapper = document.getElementById("staffWrapper");
                wrapper.scrollLeft = wrapper.scrollWidth;

            } else {
                let renderHistory = [...notesHistory];
                if (renderHistory.length > NOTES_PER_LINE * LINES_PER_PAGE) {
                    renderHistory = [ renderHistory[renderHistory.length - 1] ];
                    notesHistory = renderHistory;
                    activeNoteIndex = 0;
                }

                const renderer = new VF.Renderer(staffDiv, VF.Renderer.Backends.SVG);
                renderer.resize(400, LINES_PER_PAGE * 120 + 40); 
                const context = renderer.getContext();

                for (let i = 0; i < LINES_PER_PAGE; i++) {
                    let startIndex = i * NOTES_PER_LINE;
                    if (startIndex >= renderHistory.length) break;

                    let lineNotesData = renderHistory.slice(startIndex, startIndex + NOTES_PER_LINE);
                    let lineClef = lineNotesData[0].clef; 

                    let stave = new VF.Stave(10, 40 + (i * 120), 350);
                    stave.addClef(lineClef).addKeySignature(currentKey).setContext(context).draw();

                    let voiceNotes = lineNotesData.map(data => {
                        let vfN = new VF.StaveNote({ keys: data.keys, duration: data.duration, clef: lineClef });
                        data.accidentals.forEach((acc, idx) => {
                            if (acc) vfN.addModifier(new VF.Accidental(acc), idx);
                        });
                        return vfN;
                    });

                    const voice = new VF.Voice({ num_beats: voiceNotes.length, beat_value: 4 }).setStrict(false);
                    voice.addTickables(voiceNotes);
                    new VF.Formatter().joinVoices([voice]).format([voice], 300);
                    voice.draw(context, stave);
                }
            }
        }

        // ---------------- AUDIO ENGINE ----------------

        function noteFromPitch(frequency) {
            const noteNum = 12 * (Math.log(frequency / 440) / Math.log(2));
            return Math.round(noteNum) + 69;
        }

        function autoCorrelate(buf, sampleRate) {
            let SIZE = buf.length;
            let rms = 0;
            for (let i = 0; i < SIZE; i++) rms += buf[i] * buf[i];
            rms = Math.sqrt(rms / SIZE);
            if (rms < volumeThreshold) return -1; 

            let r1 = 0, r2 = SIZE - 1, thres = 0.2;
            for (let i = 0; i < SIZE / 2; i++) if (Math.abs(buf[i]) < thres) { r1 = i; break; }
            for (let i = 1; i < SIZE / 2; i++) if (Math.abs(buf[SIZE - i]) < thres) { r2 = SIZE - i; break; }

            buf = buf.slice(r1, r2);
            SIZE = buf.length;

            let c = new Array(SIZE).fill(0);
            for (let i = 0; i < SIZE; i++) {
                for (let j = 0; j < SIZE - i; j++) c[i] = c[i] + buf[j] * buf[j + i];
            }

            let d = 0; while (c[d] > c[d + 1]) d++;
            let maxval = -1, maxpos = -1;
            for (let i = d; i < SIZE; i++) {
                if (c[i] > maxval) { maxval = c[i]; maxpos = i; }
            }
            let T0 = maxpos;
            return sampleRate / T0;
        }

        function updatePitch() {
            requestAnimationFrame(updatePitch);
            
            if (inputSource === 'midi') return; 

            let buffer = new Float32Array(analyser.fftSize);
            analyser.getFloatTimeDomainData(buffer);
            
            let sum = 0;
            for(let i=0; i<buffer.length; i++) sum += buffer[i]*buffer[i];
            let volume = Math.sqrt(sum/buffer.length);

            if (volume > volumeThreshold) {
                silenceFrames = 0; 
                let frequency = autoCorrelate(buffer, audioContext.sampleRate);
                
                if (frequency !== -1) {
                    let note = noteFromPitch(frequency);
                    
                    if (isVoiceMode) {
                        pitchBuffer.push(note);
                        if (pitchBuffer.length > 5) pitchBuffer.shift(); 
                        let isStable = pitchBuffer.length === 5 && pitchBuffer.every(val => val === pitchBuffer[0]);
                        if (isStable) registerNotesAndDraw([note]); 
                    } else {
                        registerNotesAndDraw([note]);
                    }
                }
            } else {
                silenceFrames++;
                let requiredSilence = isVoiceMode ? 15 : 5; 
                
                if (silenceFrames > requiredSilence) {
                    activeNoteName = ""; 
                    document.getElementById('noteDisplay').style.color = "#2c3e50";
                    pitchBuffer = []; 
                }
            }
        }

        document.getElementById('startBtn').addEventListener('click', async () => {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 2048; 

            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                microphone = audioContext.createMediaStreamSource(stream);
                microphone.connect(analyser);
                updatePitch();
                
                document.getElementById('startBtn').style.display = 'none';
                document.getElementById('sourceToggle').style.display = 'inline-block';
                document.getElementById('modeToggle').style.display = 'inline-block';
                document.getElementById('instrumentToggle').style.display = 'inline-block';
                document.getElementById('pdfBtn').style.display = 'inline-block';
                document.getElementById('clearBtn').style.display = 'inline-block';
                document.getElementById('rhythmControls').style.display = 'flex';
            } catch (err) {
                alert('Microphone access denied or not found.');
            }
        });
    </script>
</body>
</html>
