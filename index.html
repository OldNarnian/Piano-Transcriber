<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Instant Pitch & MIDI Detector</title>
    
    <script src="https://cdn.jsdelivr.net/npm/vexflow@4.2.2/build/cjs/vexflow.js"></script>
    
    <style>
        body { font-family: sans-serif; text-align: center; margin-top: 20px; background-color: #f8f9fa;}
        h2 { color: #333; margin-bottom: 10px;}
        
        .controls { display: flex; justify-content: center; gap: 8px; margin-top: 15px; flex-wrap: wrap; max-width: 95%; margin-left: auto; margin-right: auto;}
        
        button { padding: 10px 16px; font-size: 15px; cursor: pointer; border-radius: 8px; border: none; box-shadow: 0 4px 6px rgba(0,0,0,0.1); color: white; transition: 0.2s; flex-grow: 1;}
        #startBtn { background-color: #007bff; font-size: 20px; padding: 15px 30px;}
        #startBtn:active { background-color: #0056b3; }
        
        /* Initial Hidden States */
        #modeToggle, #instrumentToggle, #sourceToggle, #clearBtn { display: none; }
        
        #modeToggle { background-color: #6c757d; }
        #instrumentToggle { background-color: #17a2b8; }
        #sourceToggle { background-color: #fd7e14; }
        #clearBtn { background-color: #dc3545; }
        
        .slider-container { margin-top: 20px; display: none; flex-direction: column; align-items: center; font-size: 14px; color: #555;}
        input[type="range"] { width: 80%; max-width: 300px; margin-top: 8px; }
        
        #noteDisplay { font-size: 35px; font-weight: bold; color: #2c3e50; margin-top: 15px;}
        
        #staff { display: flex; justify-content: center; margin-top: 15px; min-height: 420px; } 
    </style>
</head>
<body>

    <h2>Live Piano Transcription</h2>
    
    <div class="controls">
        <button id="startBtn">Start Application</button>
        <button id="sourceToggle">Source: Microphone</button>
        <button id="modeToggle">Layout: Sheet Music</button>
        <button id="instrumentToggle">Input: Voice Mode</button>
        <button id="clearBtn">Clear Staff</button>
    </div>

    <div class="slider-container" id="sliderContainer">
        <label for="volSlider">Mic Sensitivity Threshold: <strong id="volLabel">0.05</strong></label>
        <input type="range" id="volSlider" min="0.01" max="0.20" step="0.01" value="0.05">
    </div>
    
    <div id="noteDisplay">--</div>
    <div id="staff"></div>

    <script>
        let audioContext;
        let analyser;
        let microphone;
        
        const VF = Vex.Flow;
        let currentDrawnNote = ""; 
        const noteStrings = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];

        // State Management Variables
        let isMultiMode = false;
        let isVoiceMode = true; 
        let inputSource = 'mic'; // 'mic' or 'midi'
        let volumeThreshold = 0.05;
        
        let notesHistory = [];
        const NOTES_PER_LINE = 8;
        const LINES_PER_PAGE = 3;

        let pitchBuffer = []; 
        let silenceFrames = 0; 

        function drawEmptyStaff() {
            const staffDiv = document.getElementById("staff");
            staffDiv.innerHTML = "";
            const renderer = new VF.Renderer(staffDiv, VF.Renderer.Backends.SVG);
            renderer.resize(200, 200);
            const context = renderer.getContext();
            const stave = new VF.Stave(10, 40, 150);
            stave.addClef("treble").setContext(context).draw();
        }
        drawEmptyStaff();

        // ---------------- UI EVENT LISTENERS ----------------
        
        document.getElementById('clearBtn').addEventListener('click', () => {
            notesHistory = []; 
            currentDrawnNote = "";
            pitchBuffer = []; 
            document.getElementById("staff").innerHTML = "";
            drawEmptyStaff();
            document.getElementById('noteDisplay').innerText = "--";
        });

        document.getElementById('modeToggle').addEventListener('click', (e) => {
            isMultiMode = !isMultiMode;
            e.target.innerText = isMultiMode ? "Layout: Single Note" : "Layout: Sheet Music";
            e.target.style.backgroundColor = isMultiMode ? "#28a745" : "#6c757d"; 
            document.getElementById('clearBtn').click(); // Auto-clear on switch
        });

        document.getElementById('instrumentToggle').addEventListener('click', (e) => {
            isVoiceMode = !isVoiceMode;
            e.target.innerText = isVoiceMode ? "Input: Voice Mode" : "Input: Piano Mode";
            e.target.style.backgroundColor = isVoiceMode ? "#17a2b8" : "#e83e8c"; 
            pitchBuffer = []; 
        });

        document.getElementById('sourceToggle').addEventListener('click', async (e) => {
            if (inputSource === 'mic') {
                // Try to switch to MIDI
                try {
                    const midiAccess = await navigator.requestMIDIAccess();
                    for (let input of midiAccess.inputs.values()) {
                        input.onmidimessage = getMIDIMessage;
                    }
                    inputSource = 'midi';
                    e.target.innerText = "Source: USB MIDI";
                    e.target.style.backgroundColor = "#8e44ad"; // Purple
                    
                    // Hide mic-specific controls for a cleaner UI
                    document.getElementById('sliderContainer').style.display = 'none';
                    document.getElementById('instrumentToggle').style.display = 'none';
                    
                } catch (err) {
                    alert("MIDI could not be accessed. Your browser might not support it, or no keyboard is connected.");
                }
            } else {
                // Switch back to Mic
                inputSource = 'mic';
                e.target.innerText = "Source: Microphone";
                e.target.style.backgroundColor = "#fd7e14"; // Orange
                
                // Bring back mic controls
                document.getElementById('sliderContainer').style.display = 'flex';
                document.getElementById('instrumentToggle').style.display = 'inline-block';
            }
            document.getElementById('clearBtn').click();
        });

        document.getElementById('volSlider').addEventListener('input', (e) => {
            volumeThreshold = parseFloat(e.target.value);
            document.getElementById('volLabel').innerText = volumeThreshold.toFixed(2);
        });

        // ---------------- MIDI ENGINE ----------------

        function getMIDIMessage(midiMessage) {
            if (inputSource !== 'midi') return;
            
            let command = midiMessage.data[0];
            let note = midiMessage.data[1];
            let velocity = (midiMessage.data.length > 2) ? midiMessage.data[2] : 0;
            
            // Commands 144 to 159 are "Note On" across the 16 MIDI channels
            if (command >= 144 && command <= 159 && velocity > 0) {
                // MIDI is perfectly digital, so we bypass all stability buffers
                registerNoteAndDraw(note);
            }
        }

        // ---------------- DRAWING ENGINE ----------------

        function registerNoteAndDraw(note) {
            let noteName = noteStrings[note % 12];
            let octave = Math.floor(note / 12) - 1; 
            
            if (note >= 21 && note <= 108) {
                document.getElementById('noteDisplay').innerText = noteName + octave;
                drawNoteOnStaff(noteName, octave);
            }
        }

        function drawNoteOnStaff(noteName, octave) {
            let vfNoteString = noteName.toLowerCase() + "/" + octave;
            const clef = octave >= 4 ? "treble" : "bass";

            if (!isMultiMode) {
                if (currentDrawnNote === vfNoteString) return; 
                currentDrawnNote = vfNoteString;

                const staffDiv = document.getElementById("staff");
                staffDiv.innerHTML = ""; 

                const renderer = new VF.Renderer(staffDiv, VF.Renderer.Backends.SVG);
                renderer.resize(200, 200);
                const context = renderer.getContext();
                
                const stave = new VF.Stave(10, 40, 150);
                stave.addClef(clef).setContext(context).draw();

                let vfNote = new VF.StaveNote({ keys: [vfNoteString], duration: "q", clef: clef });
                if (noteName.includes("#")) vfNote.addModifier(new VF.Accidental("#"), 0);

                const voice = new VF.Voice({ num_beats: 1, beat_value: 4 }).setStrict(false);
                voice.addTickables([vfNote]);
                new VF.Formatter().joinVoices([voice]).format([voice], 100);
                voice.draw(context, stave);
                
            } else {
                if (currentDrawnNote === vfNoteString && inputSource === 'mic') return; 
                currentDrawnNote = vfNoteString;

                notesHistory.push({ keys: [vfNoteString], clef: clef, name: noteName });

                if (notesHistory.length > NOTES_PER_LINE * LINES_PER_PAGE) {
                    notesHistory = [ notesHistory[notesHistory.length - 1] ];
                }

                const staffDiv = document.getElementById("staff");
                staffDiv.innerHTML = ""; 

                const renderer = new VF.Renderer(staffDiv, VF.Renderer.Backends.SVG);
                renderer.resize(400, LINES_PER_PAGE * 120 + 40); 
                const context = renderer.getContext();

                for (let i = 0; i < LINES_PER_PAGE; i++) {
                    let startIndex = i * NOTES_PER_LINE;
                    if (startIndex >= notesHistory.length) break;

                    let lineNotesData = notesHistory.slice(startIndex, startIndex + NOTES_PER_LINE);
                    let lineClef = lineNotesData[0].clef; 

                    let stave = new VF.Stave(10, 40 + (i * 120), 350);
                    stave.addClef(lineClef).setContext(context).draw();

                    let voiceNotes = lineNotesData.map(data => {
                        let vfN = new VF.StaveNote({ keys: [data.keys[0]], duration: "q", clef: lineClef });
                        if (data.name.includes("#")) vfN.addModifier(new VF.Accidental("#"), 0);
                        return vfN;
                    });

                    const voice = new VF.Voice({ num_beats: voiceNotes.length, beat_value: 4 }).setStrict(false);
                    voice.addTickables(voiceNotes);
                    
                    new VF.Formatter().joinVoices([voice]).format([voice], 300);
                    voice.draw(context, stave);
                }
            }
        }

        // ---------------- AUDIO ENGINE ----------------

        function noteFromPitch(frequency) {
            const noteNum = 12 * (Math.log(frequency / 440) / Math.log(2));
            return Math.round(noteNum) + 69;
        }

        function autoCorrelate(buf, sampleRate) {
            let SIZE = buf.length;
            let rms = 0;
            for (let i = 0; i < SIZE; i++) rms += buf[i] * buf[i];
            rms = Math.sqrt(rms / SIZE);
            if (rms < volumeThreshold) return -1; 

            let r1 = 0, r2 = SIZE - 1, thres = 0.2;
            for (let i = 0; i < SIZE / 2; i++) if (Math.abs(buf[i]) < thres) { r1 = i; break; }
            for (let i = 1; i < SIZE / 2; i++) if (Math.abs(buf[SIZE - i]) < thres) { r2 = SIZE - i; break; }

            buf = buf.slice(r1, r2);
            SIZE = buf.length;

            let c = new Array(SIZE).fill(0);
            for (let i = 0; i < SIZE; i++) {
                for (let j = 0; j < SIZE - i; j++) c[i] = c[i] + buf[j] * buf[j + i];
            }

            let d = 0; while (c[d] > c[d + 1]) d++;
            let maxval = -1, maxpos = -1;
            for (let i = d; i < SIZE; i++) {
                if (c[i] > maxval) { maxval = c[i]; maxpos = i; }
            }
            let T0 = maxpos;
            return sampleRate / T0;
        }

        function updatePitch() {
            requestAnimationFrame(updatePitch);
            
            // Skip microphone math entirely if we are using USB MIDI
            if (inputSource === 'midi') return; 

            let buffer = new Float32Array(analyser.fftSize);
            analyser.getFloatTimeDomainData(buffer);
            
            let sum = 0;
            for(let i=0; i<buffer.length; i++) sum += buffer[i]*buffer[i];
            let volume = Math.sqrt(sum/buffer.length);

            if (volume > volumeThreshold) {
                silenceFrames = 0; 
                let frequency = autoCorrelate(buffer, audioContext.sampleRate);
                
                if (frequency !== -1) {
                    let note = noteFromPitch(frequency);
                    
                    if (isVoiceMode) {
                        pitchBuffer.push(note);
                        if (pitchBuffer.length > 5) pitchBuffer.shift(); 
                        let isStable = pitchBuffer.length === 5 && pitchBuffer.every(val => val === pitchBuffer[0]);
                        if (isStable) registerNoteAndDraw(note);
                    } else {
                        registerNoteAndDraw(note);
                    }
                }
            } else {
                silenceFrames++;
                let requiredSilence = isVoiceMode ? 15 : 5; 
                
                if (silenceFrames > requiredSilence) {
                    currentDrawnNote = ""; 
                    document.getElementById('noteDisplay').style.color = "#2c3e50";
                    pitchBuffer = []; 
                }
            }
        }

        document.getElementById('startBtn').addEventListener('click', async () => {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 2048; 

            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                microphone = audioContext.createMediaStreamSource(stream);
                microphone.connect(analyser);
                updatePitch();
                
                // Unhide the main UI
                document.getElementById('startBtn').style.display = 'none';
                document.getElementById('sourceToggle').style.display = 'inline-block';
                document.getElementById('modeToggle').style.display = 'inline-block';
                document.getElementById('instrumentToggle').style.display = 'inline-block';
                document.getElementById('clearBtn').style.display = 'inline-block';
                document.getElementById('sliderContainer').style.display = 'flex';
            } catch (err) {
                alert('Microphone access denied or not found.');
            }
        });
    </script>
</body>
</html>

